<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Karameta</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 50%, #0f1419 100%);
            background-attachment: fixed;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #1a1f2e;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7), 0 0 40px rgba(212, 175, 55, 0.1);
            overflow: hidden;
            border: 1px solid rgba(212, 175, 55, 0.2);
        }

        .header {
            background: linear-gradient(135deg, #0f1419 0%, #1a1f3a 100%);
            color: #d4af37;
            padding: 40px 40px 0 40px;
            text-align: center;
            border-bottom: 2px solid rgba(212, 175, 55, 0.3);
            position: relative;
        }

        .tab-nav {
            display: flex;
            gap: 4px;
            position: relative;
            bottom: -2px;
        }

        .tab-button {
            background: rgba(15, 20, 25, 0.6);
            border: none;
            color: #7c8db0;
            padding: 10px 24px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            transition: all 0.3s;
            position: relative;
            border-top: 1px solid rgba(212, 175, 55, 0.2);
            border-left: 1px solid rgba(212, 175, 55, 0.2);
            border-right: 1px solid rgba(212, 175, 55, 0.2);
            border-bottom: 2px solid rgba(212, 175, 55, 0.3);
        }

        .tab-button:hover {
            color: #d4af37;
            background: rgba(15, 20, 25, 0.8);
            border-top-color: rgba(212, 175, 55, 0.4);
        }

        .tab-button.active {
            background: #0f1419;
            color: #d4af37;
            border-top-color: rgba(212, 175, 55, 0.3);
            border-left-color: rgba(212, 175, 55, 0.3);
            border-right-color: rgba(212, 175, 55, 0.3);
            border-bottom: 2px solid #0f1419;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.15);
        }

        .github-link {
            position: absolute;
            top: 20px;
            right: 30px;
            width: 40px;
            height: 40px;
            opacity: 0.8;
            transition: all 0.3s ease;
            filter: drop-shadow(0 0 8px rgba(212, 175, 55, 0.3));
        }

        .github-link:hover {
            opacity: 1;
            transform: scale(1.1) rotate(5deg);
            filter: drop-shadow(0 0 15px rgba(212, 175, 55, 0.6));
        }

        .github-link svg {
            width: 100%;
            height: 100%;
            fill: #d4af37;
        }

        .header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 1px;
            background: linear-gradient(90deg, transparent, #d4af37, transparent);
        }

        .header h1 {
            font-size: 36px;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
            letter-spacing: 2px;
        }

        .header p {
            font-size: 18px;
            opacity: 0.8;
            color: #a8b2d1;
        }

        .controls {
            padding: 30px 40px;
            background: #0f1419;
            border-bottom: 1px solid rgba(212, 175, 55, 0.2);
            display: flex;
            gap: 40px;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .control-group label {
            color: #d4af37;
            font-weight: 600;
        }

        .date-inputs {
            display: flex;
            gap: 12px;
            align-items: center;
            color: #a8b2d1;
        }

        input[type="date"] {
            padding: 10px 16px;
            font-size: 16px;
            border: 2px solid rgba(212, 175, 55, 0.3);
            border-radius: 8px;
            background: #1a1f2e;
            color: #d4af37;
            cursor: pointer;
            font-family: inherit;
        }

        input[type="date"]::-webkit-calendar-picker-indicator {
            filter: invert(1) sepia(100%) saturate(1000%) hue-rotate(360deg) brightness(1.2);
            cursor: pointer;
        }

        /* Multiselect Styling */
        .combo-search {
            flex: 1;
            padding: 10px 16px;
            font-size: 14px;
            border: 2px solid rgba(212, 175, 55, 0.3);
            border-radius: 8px 8px 0 0;
            border-bottom: none;
            background: #1a1f2e;
            color: #d4af37;
            font-family: inherit;
            transition: all 0.3s;
        }

        .combo-search::placeholder {
            color: rgba(168, 178, 209, 0.5);
        }

        .combo-search:focus {
            outline: none;
            border-color: #d4af37;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
        }

        .multiselect-container {
            width: 100%;
            height: 170px;
            border: 2px solid rgba(212, 175, 55, 0.3);
            border-radius: 0 0 8px 8px;
            background: #1a1f2e;
            overflow-y: auto;
            padding: 8px;
        }

        .multiselect-wrapper {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .multiselect-option {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: #252a3d;
            border-radius: 16px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.2s;
            color: #a8b2d1;
            font-size: 13px;
            user-select: none;
        }

        .multiselect-option:hover {
            background: #2c3349;
            border-color: rgba(212, 175, 55, 0.5);
        }

        .multiselect-option input {
            accent-color: #d4af37;
        }

        .multiselect-option:has(input:checked) {
            background: rgba(212, 175, 55, 0.1);
            border-color: #d4af37;
            color: #d4af37;
            font-weight: 600;
        }

        .multiselect-option.hidden {
            display: none;
        }

        .content {
            padding: 40px;
            background: #1a1f2e;
        }

        .stats-grid {
            display: flex;
            gap: 16px;
            margin-top: 16px;
        }

        .stat-card {
            background: linear-gradient(135deg, #1e2a47 0%, #2a3550 100%);
            color: #e8eaf6;
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s, box-shadow 0.3s;
            border: 1px solid rgba(212, 175, 55, 0.2);
            position: relative;
            overflow: hidden;
            flex: 1;
            min-width: 0;
        }

        .stat-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.7;
            margin-bottom: 8px;
            color: #d4af37;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 700;
            line-height: 1;
            color: #ffffff;
            text-shadow: 0 2px 10px rgba(212, 175, 55, 0.3);
        }

        .section-title {
            font-size: 28px;
            font-weight: 700;
            color: #d4af37;
            margin-bottom: 24px;
            padding-bottom: 12px;
            border-bottom: 3px solid rgba(212, 175, 55, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .combo-list {
            display: grid;
            gap: 16px;
        }

        .combo-item {
            background: #0f1419;
            padding: 24px;
            border-radius: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s;
            border: 2px solid rgba(212, 175, 55, 0.2);
        }

        .combo-item:hover {
            background: #1a1f2e;
            border-color: #d4af37;
            box-shadow: 0 4px 12px rgba(212, 175, 55, 0.2);
            transform: translateX(4px);
        }

        .combo-rank {
            font-size: 24px;
            font-weight: 700;
            color: #d4af37;
            width: 30px;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        .combo-info {
            flex: 1;
        }

        .combo-name {
            font-size: 18px;
            font-weight: 600;
            color: #e8eaf6;
            margin-bottom: 4px;
        }

        .combo-details {
            font-size: 14px;
            color: #7c8db0;
        }

        .combo-stats {
            text-align: right;
        }

        .combo-count {
            font-size: 32px;
            font-weight: 700;
            color: #d4af37;
            line-height: 1;
        }

        .combo-percentage {
            font-size: 14px;
            color: #7c8db0;
            margin-top: 4px;
        }

        .trend-value {
            font-size: 16px;
            font-weight: 700;
        }

        .trend-positive {
            color: #2ed573;
        }

        .trend-negative {
            color: #ff4757;
        }

        .trend-neutral {
            color: #a4b0be;
        }

        .loading {
            text-align: center;
            padding: 60px;
            color: #7c8db0;
            font-size: 18px;
        }

        .error {
            background: rgba(255, 71, 87, 0.1);
            color: #ff4757;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid rgba(255, 71, 87, 0.3);
        }

        .chart-container {
            background: #0f1419;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            margin-bottom: 40px;
            border: 1px solid rgba(212, 175, 55, 0.2);
        }

        .chart-wrapper {
            position: relative;
            height: 400px;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .chart-wrapper {
                height: 300px;
            }

            .header h1 {
                font-size: 28px;
            }

            .combo-item {
                flex-direction: column;
                text-align: center;
                gap: 16px;
            }

            .combo-rank {
                width: auto;
            }

            .combo-stats {
                text-align: center;
            }

            .trend-grid {
                flex-direction: column;
            }
        }

        .trend-grid {
            display: flex;
            gap: 24px;
            margin-bottom: 24px;
        }

        .trend-column {
            flex: 1;
            min-width: 300px;
        }

        .trend-title {
            font-size: 20px;
            margin-bottom: 16px;
            color: #d4af37;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-toggle {
            background: #252a3d;
            border: 1px solid rgba(212, 175, 55, 0.3);
            color: #d4af37;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn-toggle:hover {
            background: #2c3349;
            border-color: #d4af37;
        }

        .btn-toggle.active {
            background: rgba(212, 175, 55, 0.2);
            border-color: #d4af37;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
        }

        .toggle-group {
            display: flex;
            gap: 8px;
            background: #0f1419;
            padding: 4px;
            border-radius: 10px;
            border: 1px solid rgba(212, 175, 55, 0.1);
        }
    </style>
</head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J3N4JRTG44"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-J3N4JRTG44');
</script>

<body>
    <div class="container">
        <div class="header">
            <a href="https://github.com/ravarix/karameta" target="_blank" class="github-link" title="View on GitHub">
                <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
                    <path
                        d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z" />
                </svg>
            </a>
            <h1>Karabast Statistics Dashboard</h1>
            <p>Star Wars: Unlimited Meta Analysis</p>
            <div class="tab-nav">
                <button class="tab-button active" id="btnPremier" onclick="setFormat('premier')">Premier</button>
                <button class="tab-button" id="btnNextSetPreview" onclick="setFormat('nextSetPreview')">Next Set
                    Preview</button>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <div class="control-group">
                    <label>Date Range:</label>
                    <div class="date-inputs">
                        <input type="date" id="startDate">
                        <span>to</span>
                        <input type="date" id="endDate">
                    </div>
                </div>

                <div style="display: flex; gap: 20px; align-items: flex-end; margin-top: 5px;">
                    <div class="control-group">
                        <label>Data Source:</label>
                        <div class="toggle-group">
                            <button class="btn-toggle active" id="btnGames"
                                onclick="setDataSource('games')">Games</button>
                            <button class="btn-toggle" id="btnPlaytime"
                                onclick="setDataSource('playtime')">Playtime</button>
                        </div>
                    </div>
                    <div class="stat-card" style="margin: 0; flex: 1;">
                        <div class="stat-label" id="lblTotalGames" style="margin-bottom: 4px;">Games in Range</div>
                        <div class="stat-value" id="valTotalGames" style="font-size: 18px;">-</div>
                    </div>
                </div>
            </div>

            <div class="control-group" style="flex: 1;">
                <div style="display: flex; gap: 12px; align-items: center; margin-bottom: -12px;">
                    <label style="margin: 0; white-space: nowrap;">Combinations to Trend:</label>
                    <input type="text" class="combo-search" id="comboSearch" placeholder="Search combinations...">
                </div>
                <div class="multiselect-container" id="comboSelect">
                    <div class="multiselect-placeholder">Loading...</div>
                </div>
            </div>
        </div>

        <div id="content" class="content">
            <div class="loading">Loading statistics...</div>
        </div>
    </div>

    <script>
        // Global State
        let statsData = null;
        let cardData = null;
        let leaderAspects = {};
        let baseAspects = {};
        let leaderNames = {};
        let baseNames = {};
        let leaderNameToId = {};
        let baseNameToId = {};
        let trendCalculationMode = 'absolute'; // 'absolute' or 'relative'
        let minGamesThreshold = 30;
        let currentDataSource = 'games'; // 'games' or 'playtime'
        let currentFormat = 'premier'; // 'premier', 'open' or 'nextSetPreview'
        let currentWinMode = 'bestOfOne' // 'bestOfOne' or 'bestOfThree'
        let cachedStats = {};
        const _dailyTotalCache = {};
        const ghRoot = 'https://raw.githubusercontent.com/Ravarix/karameta/refs/heads/main/';

        const alignments = ["Heroism", "Villainy"];

        const ASPECT_COLORS = {
            'Aggression': '#cc0000', // Red
            'Command': '#009900',    // Green
            'Cunning': '#ffcc00',    // Yellow
            'Vigilance': '#0077cc',  // Blue
            'Heroism': '#ffffff',    // White
            'Villainy': '#000000',   // Dark/Black
            'Star': '#808080'        // Neutral
        };

        // Helper to cache daily totals since we need them often
        function getTotalGamesForDate(date) {
            const statsKey = `${currentDataSource}_${currentFormat}_${currentWinMode}`;
            if (_dailyTotalCache[statsKey] && _dailyTotalCache[statsKey][date] !== undefined) {
                return _dailyTotalCache[statsKey][date];
            }

            let total = 0;
            for (const stats of Object.values(statsData.stats)) {
                total += (stats.dailyCounts[date] || 0);
            }
            if (!_dailyTotalCache[statsKey]) _dailyTotalCache[statsKey] = {};
            _dailyTotalCache[statsKey][date] = total;
            return total;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function addDays(dateStr, days) {
            const parts = dateStr.split('-');
            const d = new Date(Date.UTC(Number(parts[0]), Number(parts[1]) - 1, Number(parts[2])));
            d.setUTCDate(d.getUTCDate() + days);
            return d.toISOString().split('T')[0];
        }

        function getAspectsByName(leaderName, baseName) {
            return getAspects(leaderNameToId[leaderName.trim()], baseNameToId[baseName.trim()]);
        }

        function getAspects(leader, base) {
            const aspects = new Set();

            // Add Leader Aspects
            if (leaderAspects[leader]) {
                leaderAspects[leader].forEach(a => aspects.add(a));
            }

            // Add Base Aspect
            if (baseAspects[base]) {
                baseAspects[base].forEach(a => aspects.add(a));
            }
            return aspects;
        }

        function reverseComboNameLookup(comboName) {
            const [leader, base] = comboName.split('/');
            return leaderNameToId[leader.trim()] + '/' + baseNameToId[base.trim()];
        }

        function translateComboName(comboName) {
            const [leader, base] = comboName.split('/');
            return leaderNames[leader.trim()] + '/' + baseNames[base.trim()];
        }

        function getComboColor(leader, base) {
            const aspects = getAspects(leader, base);

            const colors = [];
            aspects.forEach(a => {
                if (ASPECT_COLORS[a]) colors.push(hexToRgb(ASPECT_COLORS[a]));
            });

            if (colors.length === 0) return '#a4b0be'; // Default gray

            // Mix colors
            let r = 0, g = 0, b = 0;
            colors.forEach(c => {
                r += c.r;
                g += c.g;
                b += c.b;
            });

            r = Math.round(r / colors.length);
            g = Math.round(g / colors.length);
            b = Math.round(b / colors.length);

            return `rgb(${r}, ${g}, ${b})`;
        }

        // Parse query parameters
        function parseQueryParams() {
            const urlParams = new URLSearchParams(window.location.search);

            // Set winMode from query parameter if valid
            const winModeParam = urlParams.get('winMode');
            if (winModeParam === 'bestOfOne' || winModeParam === 'bestOfThree') {
                currentWinMode = winModeParam;
            }
        }

        // Initialization
        async function init() {
            try {
                // Parse query parameters first
                parseQueryParams();

                // Load parallel data
                await Promise.all([loadCards(), loadStats()]);

                // Find all available dates across all combos to establish range
                const allDatesSet = new Set();
                Object.values(statsData.stats).forEach(stat => {
                    Object.keys(stat.dailyCounts).forEach(d => allDatesSet.add(d));
                });
                const dates = Array.from(allDatesSet).sort();

                if (dates.length > 0) {
                    const lastDate = dates[dates.length - 1];
                    // Default to last 7 days
                    const firstDate = dates[Math.max(0, dates.length - 7)];

                    document.getElementById('endDate').value = lastDate;
                    document.getElementById('startDate').value = firstDate;

                    // Set min/max
                    const minStr = dates[0];
                    const maxStr = dates[dates.length - 1];
                    ['startDate', 'endDate'].forEach(id => {
                        const el = document.getElementById(id);
                        el.min = minStr;
                        el.max = maxStr;
                        el.addEventListener('change', updateView);
                        el.addEventListener('input', updateView);
                    });
                }

                initComboSelect();
                updateView(); // Initial render

            } catch (e) {
                showError("Initialization failed: " + e.message);
                console.error(e);
            }
        }

        async function loadCards() {
            const resp = await fetch(ghRoot + 'data/cards.json');
            if (!resp.ok) throw new Error("Failed to load cards.json");
            cardData = await resp.json();

            cardData.leaders.forEach(l => {
                const displayName = `${l.name}(${l.setName})`;
                leaderAspects[l.id] = l.aspects;
                leaderNames[l.id] = displayName;
                leaderNameToId[displayName] = l.id;
            });
            cardData.bases.forEach(b => {
                baseAspects[b.dataKey] = b.aspects
                baseNames[b.dataKey] = b.name;
                baseNameToId[b.name] = b.dataKey;
            });
        }

        async function loadStats() {
            const fileName = currentDataSource === 'games' ? `stats_${currentFormat}_${currentWinMode}.json` : `playtime_stats_${currentFormat}_${currentWinMode}.json`;
            const statsKey = `${currentDataSource}_${currentFormat}`;

            if (cachedStats[statsKey]) {
                statsData = cachedStats[statsKey];
                return;
            }

            const resp = await fetch(ghRoot + 'data/' + fileName + '?t=' + Date.now());
            if (!resp.ok) throw new Error(`Failed to load ${fileName}`);
            statsData = await resp.json();
            cachedStats[statsKey] = statsData;
        }

        async function setDataSource(source) {
            if (currentDataSource === source) return;
            currentDataSource = source;

            // Update UI
            document.getElementById('btnGames').classList.toggle('active', source === 'games');
            document.getElementById('btnPlaytime').classList.toggle('active', source === 'playtime');

            // Update labels
            document.getElementById('lblTotalGames').textContent = source === 'games' ? 'Games in Range' : 'Playtime in Range';

            // Update minGamesThreshold based on data source
            minGamesThreshold = source === 'games' ? 30 : 600;

            // Reload and update
            const content = document.getElementById('content');
            content.innerHTML = '<div class="loading">Loading ' + source + ' statistics...</div>';

            try {
                await loadStats();
                initComboSelect()
                updateView();
            } catch (e) {
                showError("Failed to switch data source: " + e.message);
            }
        }

        async function setFormat(format) {
            if (currentFormat === format) return;
            currentFormat = format;

            // Update UI
            document.getElementById('btnPremier').classList.toggle('active', format === 'premier');
            document.getElementById('btnNextSetPreview').classList.toggle('active', format === 'nextSetPreview');

            // Reload and update
            const content = document.getElementById('content');
            const formatLabel = format === 'premier' ? 'Premier' : 'Next Set Preview';
            content.innerHTML = '<div class="loading">Loading ' + formatLabel + ' statistics...</div>';

            try {
                await loadStats();
                initComboSelect()
                updateView();
            } catch (e) {
                showError("Failed to switch format: " + e.message);
            }
        }

        function getDateRange() {
            const start = document.getElementById('startDate').value;
            const end = document.getElementById('endDate').value;
            return {
                start: start || '0000-00-00',
                end: end || '9999-12-31'
            };
        }

        function getSelectedCombos() {
            const checkboxes = document.querySelectorAll('.multiselect-option input:checked');
            return Array.from(checkboxes).map(cb => cb.value);
        }

        function updateView() {
            if (!statsData) return;

            const { start, end } = getDateRange();
            const selectedCombos = getSelectedCombos();

            // 1. Process data for the aggregation view (Pie & List)
            const aggregated = aggregateData(start, end);

            // 2. Process data for the trend chart
            const trends = processTrendData(selectedCombos, start, end);

            // 3. Render everything
            renderDashboard(aggregated, trends);
        }

        function aggregateData(startDate, endDate) {
            const aggregated = {
                totalGameCount: 0,
                combinations: {},
                topCombinations: []
            };

            for (const [comboName, stats] of Object.entries(statsData.stats)) {
                let comboCount = 0;
                for (const [date, count] of Object.entries(stats.dailyCounts)) {
                    if (date >= startDate && date <= endDate) {
                        comboCount += count;
                    }
                }

                if (comboCount > 0) {
                    aggregated.combinations[comboName] = comboCount;
                    aggregated.totalGameCount += comboCount;
                }
            }

            // Calculate Top Combinations (keep for Pie Chart)
            aggregated.topCombinations = Object.entries(aggregated.combinations)
                .map(([name, count]) => {
                    const [leader, base] = name.split('/');
                    return {
                        combination: { leader, base },
                        count,
                        percentage: (count / aggregated.totalGameCount) * 100
                    };
                })
                .sort((a, b) => b.count - a.count);

            // Calculate Hot & Cold Trends
            // Use 5-day window around start date for baseline smoothing
            const startWindowDates = [];
            for (let i = -2; i <= 2; i++) {
                startWindowDates.push(addDays(startDate, i));
            }

            let startWindowTotalGames = 0;
            startWindowDates.forEach(d => startWindowTotalGames += getTotalGamesForDate(d));

            const endTotal = getTotalGamesForDate(endDate);
            const trendList = [];

            // We relax the check: if startWindow has ANY data, we proceed.
            // End date strict check remains.
            if (startWindowTotalGames > 0 && endTotal > 0) {
                for (const [comboName, stats] of Object.entries(statsData.stats)) {
                    // Start Rate based on Window
                    let startComboCount = 0;
                    startWindowDates.forEach(d => startComboCount += (stats.dailyCounts[d] || 0));

                    if (startComboCount === 0 && (stats.dailyCounts[endDate] || 0) === 0) continue;

                    const endCount = stats.dailyCounts[endDate] || 0;
                    const startRate = (startComboCount / startWindowTotalGames) * 100;
                    const endRate = (endCount / endTotal) * 100;

                    if (startComboCount / 5 < minGamesThreshold && endCount < minGamesThreshold) {
                        continue;
                    }

                    let absDelta = endRate - startRate;
                    let relDelta = 0;
                    // Relative Change
                    if (startRate > 0) {
                        relDelta = ((endRate - startRate) / startRate) * 100;
                    } else if (endRate > 0) {
                        // Infinite growth technically, treat as max sort magnitude but display specially?
                        // For simplicity let's cap it or treat it as 100% or just high number
                        relDelta = 100;
                    }

                    trendList.push({
                        name: comboName,
                        delta: trendCalculationMode === 'absolute' ? absDelta : relDelta,
                        absDelta: absDelta,
                        relDelta: relDelta,
                        endRate: endRate,
                        startRate: startRate
                    });
                }
            }
            // Sort by absolute change magnitude
            aggregated.hotColdCombinations = trendList.sort((a, b) => Math.abs(b.delta) - Math.abs(a.delta));

            return aggregated;
        }

        function addComboToTrend(comboName) {
            const checkboxes = document.querySelectorAll('.multiselect-option input');
            for (const cb of checkboxes) {
                if (cb.value === comboName) {
                    if (!cb.checked) {
                        cb.checked = true;
                        // Trigger reordering and update
                        reorderComboOptions();
                        updateView();

                        // Scroll to chart
                        document.querySelector('.chart-container').scrollIntoView({ behavior: 'smooth' });
                    }
                    return;
                }
            }
        }

        function processTrendData(comboKeys, startDate, endDate) {
            // Collect all unique dates in the range that have data
            const allDates = new Set();
            comboKeys.forEach(name => {
                const stats = statsData.stats[name];
                if (stats) {
                    Object.keys(stats.dailyCounts).forEach(d => {
                        if (d >= startDate && d <= endDate) allDates.add(d);
                    });
                }
            });
            const sortedDates = Array.from(allDates).sort();

            const datasets = comboKeys.map((name, idx) => {
                const stats = statsData.stats[name];
                const dataPoints = sortedDates.map(date => {
                    // To get percentage, we need the total games for that specific day
                    // This is expensive to calculate every time, but doing it on fly for now
                    const totalGamesForDay = getTotalGamesForDate(date);
                    if (totalGamesForDay === 0) return 0;

                    const count = stats?.dailyCounts?.[date] || 0;
                    return (count / totalGamesForDay) * 100;
                });

                const [leader, base] = name.split('/');
                const color = getComboColor(leader, base);

                return {
                    label: leaderNames[leader] + '/' + baseNames[base],
                    data: dataPoints,
                    borderColor: color,
                    backgroundColor: color,
                    pointBackgroundColor: color,
                    pointRadius: 3,
                };
            });

            return { labels: sortedDates, datasets };
        }

        function minutesToDays(mins) {
            let cd = 24 * 60,
                ch = 60,
                day = Math.floor(mins / cd),
                hour = Math.floor((mins - day * cd) / ch),
                minute = Math.round(mins - day * cd - hour * ch),
                pad = n => { return n < 10 ? '0' + n : n; };
            if (minute === 60) {
                hour++;
                minute = 0;
            }
            if (hour === 24) {
                day++;
                hour = 0;
            }
            return [(day > 0 ? `${day}d` : ""), (hour > 0 ? `${pad(hour)}h ` : ''), `${pad(minute)}m`].join(" ");
        }

        function initComboSelect() {
            // Find the latest date with data to use for "current day" defaults
            let maxDate = '0000-00-00';
            // Sample a few to find the max date range efficiently
            const sample = Object.values(statsData.stats).slice(0, 50);
            for (const s of sample) {
                const dates = Object.keys(s.dailyCounts);
                if (dates.length) {
                    const last = dates.sort().pop();
                    if (last > maxDate) maxDate = last;
                }
            }

            // Sort by count on the maxDate
            const sortedCombos = Object.entries(statsData.stats)
                .map(([name, stats]) => ({
                    name,
                    // specific day count > total count > name
                    dayCount: stats.dailyCounts[maxDate] || 0,
                    totalCount: stats.count
                }))
                .sort((a, b) => {
                    if (b.dayCount !== a.dayCount) return b.dayCount - a.dayCount;
                    return b.totalCount - a.totalCount;
                })
                .map(item => item.name);

            const container = document.getElementById('comboSelect');
            container.innerHTML = '';

            // Improved MultiSelect UI
            const wrapper = document.createElement('div');
            wrapper.className = 'multiselect-wrapper';

            // Initialize with top 5 selected
            const defaultSelected = new Set(sortedCombos.slice(0, 5));

            // Create all options (will be sorted later)
            const allOptions = [];

            sortedCombos.forEach(combo => {
                const label = document.createElement('label');
                label.className = 'multiselect-option';
                label.dataset.comboName = combo;
                label.dataset.comboDisplayName = translateComboName(combo).toLowerCase();

                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.value = combo;
                cb.checked = defaultSelected.has(combo);
                cb.addEventListener('change', () => {
                    reorderComboOptions();
                    updateView();
                });

                const text = document.createElement('span');
                text.textContent = translateComboName(combo);

                label.appendChild(cb);
                label.appendChild(text);
                allOptions.push(label);
            });

            // Add all options to wrapper
            allOptions.forEach(option => wrapper.appendChild(option));
            container.appendChild(wrapper);

            // Setup search functionality
            const searchInput = document.getElementById('comboSearch');
            searchInput.addEventListener('input', (e) => {
                filterComboOptions(e.target.value);
            });

            // Initial ordering (selected first)
            reorderComboOptions();
        }

        function reorderComboOptions() {
            const wrapper = document.querySelector('.multiselect-wrapper');
            if (!wrapper) return;

            const options = Array.from(wrapper.querySelectorAll('.multiselect-option'));

            // Separate selected and unselected
            const selected = options.filter(opt => opt.querySelector('input').checked);
            const unselected = options.filter(opt => !opt.querySelector('input').checked);

            // Clear wrapper
            wrapper.innerHTML = '';

            // Add selected first, then unselected
            selected.forEach(opt => wrapper.appendChild(opt));
            unselected.forEach(opt => wrapper.appendChild(opt));
        }

        function filterComboOptions(searchText) {
            const wrapper = document.querySelector('.multiselect-wrapper');
            if (!wrapper) return;

            const options = wrapper.querySelectorAll('.multiselect-option');
            const search = searchText.toLowerCase().trim();

            options.forEach(option => {
                const displayName = option.dataset.comboDisplayName;
                if (search === '' || displayName.includes(search)) {
                    option.classList.remove('hidden');
                } else {
                    option.classList.add('hidden');
                }
            });
        }

        let pieChartInstance = null;
        let baseChartInstance = null;
        let trendChartInstance = null;

        function renderDashboard(aggregated, trends) {
            const content = document.getElementById('content');

            // Only rebuild structure if missing (first load)
            if (!document.getElementById('trendChartContainer')) {
                content.innerHTML = `
                    <div class="chart-container" id="trendChartContainer">
                        <h2 class="section-title">Play Rate Trends</h2>
                        <div class="chart-wrapper">
                            <canvas id="trendChart"></canvas>
                        </div>
                    </div>

                    <div style="display: flex; gap: 24px; margin-bottom: 40px; flex-wrap: wrap;">
                        <!-- Left Side: Distribution -->
                        <div style="flex: 1; min-width: 350px;">
                            <div class="chart-container">
                                <div style="display: flex; flex-direction: column; gap: 20px;">
                                    <h2 class="section-title">Distribution</h2>
                                    <div class="chart-wrapper" style="height: 350px;">
                                        <canvas id="pieChart"></canvas>
                                    </div>
                                    <h2 class="section-title">Base & Aspects</h2>
                                    <div class="chart-wrapper" style="height: 350px;">
                                        <canvas id="basePieChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Right Side: Hot & Cold -->
                        <div style="flex: 2; min-width: 400px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                                <h2 class="section-title" style="margin-bottom: 0; border: none;">Hot & Cold</h2>
                                <div style="display: flex; gap: 12px; align-items: center;">
                                    <div style="display: flex; align-items: center; gap: 8px; color: #a8b2d1; font-size: 14px;">
                                        <label for="minGamesInput">${currentDataSource === 'games' ? 'Min Games:' : 'Min Minutes:'}</label>
                                        <input type="number" id="minGamesInput" value="${minGamesThreshold}" min="0" 
                                            style="width: 70px; background: #252a3d; border: 1px solid rgba(212, 175, 55, 0.3); color: #d4af37; padding: 6px 10px; border-radius: 6px; font-weight: 600;"
                                            onchange="updateMinGames(this.value)">
                                    </div>
                                    <button class="btn-toggle" onclick="toggleTrendMode()" id="btnTrendMode">
                                        Mode: ${trendCalculationMode === 'absolute' ? 'Absolute %' : 'Relative %'}
                                    </button>
                                </div>
                            </div>
                            
                            <div class="trend-grid">
                                <div class="trend-column">
                                    <h3 class="trend-title">üî• Heating Up</h3>
                                    <div class="combo-list" id="hotList"></div>
                                </div>
                                <div class="trend-column">
                                    <h3 class="trend-title">‚ùÑÔ∏è Cooling Down</h3>
                                    <div class="combo-list" id="coldList"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Update Stats
            document.getElementById('valTotalGames').textContent = currentDataSource === 'games' ? aggregated.totalGameCount.toLocaleString() : minutesToDays(aggregated.totalGameCount);

            // Split into Hot & Cold
            const hotItems = aggregated.hotColdCombinations.filter(x => x.delta > 0);
            const coldItems = aggregated.hotColdCombinations.filter(x => x.delta < 0);

            // Render Helper
            const renderList = (items, containerId) => {
                const container = document.getElementById(containerId);
                container.innerHTML = items.slice(0, 20).map((item, i) => {
                    const [leader, base] = item.name.split('/');
                    const delta = trendCalculationMode === 'absolute' ? item.absDelta : item.relDelta;
                    const otherDelta = trendCalculationMode === 'absolute' ? item.relDelta : item.absDelta;
                    const isPositive = delta > 0;
                    const sign = isPositive ? '+' : '';
                    const prefix = trendCalculationMode === 'absolute'
                        ? (isPositive ? 'x' : '-x')
                        : (isPositive ? '+' : '-');
                    const deltaClass = isPositive ? 'trend-positive' : (delta < 0 ? 'trend-negative' : 'trend-neutral');
                    const escapedName = item.name.replace(/'/g, "\\'");

                    return `
                    <div class="combo-item" style="cursor: pointer;" onclick="addComboToTrend('${escapedName}')" title="Click to add to trends">
                        <div class="combo-rank" style="font-size: 18px;">${i + 1}</div>
                        <div class="combo-info">
                            <div class="combo-name">${leaderNames[leader]}<br>${baseNames[base]}</div>
                            <div class="combo-details">
                            Start: ${item.startRate.toFixed(1)}% ‚Üí End: ${item.endRate.toFixed(1)}% (<span class="${deltaClass}">${prefix}${Math.abs(otherDelta).toFixed(1)}%</span>)
                            </div>
                        </div>
                        <div class="combo-stats">
                            <div class="trend-value ${deltaClass}">${sign}${delta.toFixed(2)}%</div>
                            <div class="combo-percentage" style="font-size: 12px;">Change</div>
                        </div>
                    </div>
                `}).join('');
            };

            renderList(hotItems, 'hotList');
            renderList(coldItems, 'coldList');

            renderPieChart(aggregated);
            renderBaseChart(aggregated);
            renderTrendChart(trends);
        }

        function toggleTrendMode() {
            trendCalculationMode = trendCalculationMode === 'absolute' ? 'relative' : 'absolute';
            document.getElementById('btnTrendMode').textContent = `Mode: ${trendCalculationMode === 'absolute' ? 'Absolute %' : 'Relative %'}`;
            updateView();
        }

        function updateMinGames(val) {
            minGamesThreshold = parseInt(val) || 0;
            updateView();
        }

        function renderTrendChart(trendData) {
            const ctx = document.getElementById('trendChart').getContext('2d');

            if (trendChartInstance) {
                trendChartInstance.destroy();
            }

            trendChartInstance = new Chart(ctx, {
                type: 'line',
                data: trendData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: { color: '#a8b2d1' }
                        },
                        title: {
                            display: true,
                            text: 'Daily Play Rate Percentage',
                            color: '#d4af37'
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const comboName = context.dataset.label || '';
                                    const date = context.chart.data.labels[context.dataIndex];
                                    const percentage = context.parsed.y;
                                    const stats = statsData.stats[reverseComboNameLookup(comboName)];
                                    const value = stats?.dailyCounts?.[date] || 0;
                                    const formattedValue = currentDataSource === 'games' ? value.toLocaleString() : minutesToDays(value);
                                    return `${comboName}: ${percentage.toFixed(2)}% (${formattedValue})`;
                                }
                            },
                            itemSort: function (a, b) {
                                return b.raw - a.raw;
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#a8b2d1' },
                            title: { display: true, text: 'Play Rate %', color: '#a8b2d1' }
                        },
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#a8b2d1' }
                        }
                    }
                }
            });
        }

        function renderPieChart(data) {
            // Logic similar to old chart but using aggregated data
            // (Simplified for brevity but maintaining features)
            const ctx = document.getElementById('pieChart').getContext('2d');

            if (pieChartInstance) {
                pieChartInstance.destroy();
            }

            // Prepare Pie Data
            const total = data.totalGameCount;
            let others = 0;
            const labels = [];
            const values = [];
            const deckColors = []

            data.topCombinations.forEach(c => {
                if (c.percentage > 0.1) {
                    labels.push(`${leaderNames[c.combination.leader]} / ${baseNames[c.combination.base]}`);
                    values.push(c.count);
                    deckColors.push(getComboColor(c.combination.leader, c.combination.base));
                } else {
                    others += c.count;
                }
            });

            if (others > 0) {
                labels.push('Others');
                values.push(others);
                deckColors.push(getComboColor("na", "bro"));
            }

            // // Generate Colors for Decks
            // const deckColors = labels.map(label => {
            //     const [leader, base] = label.split('/');
            //     return getComboColor(leader, base);
            // });

            pieChartInstance = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            data: values,
                            backgroundColor: deckColors,
                            borderColor: '#000000',
                            borderWidth: 0,
                            hoverBorderColor: '#ffffff',
                            hoverOffset: 20,
                            label: 'Decks'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    let label = context.label || '';
                                    let datasetTotal = total; // Default to total games for Decks

                                    const value = context.parsed || 0;
                                    const percentage = ((value / datasetTotal) * 100).toFixed(1);
                                    const formattedValue = currentDataSource === 'games' ? value.toLocaleString() : minutesToDays(value);
                                    return `${label}: ${percentage}% (${formattedValue})`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function renderBaseChart(data) {
            const ctx = document.getElementById('basePieChart').getContext('2d');

            if (baseChartInstance) {
                baseChartInstance.destroy();
            }

            const baseCounts = {};
            for (const [combo, count] of Object.entries(data.combinations)) {
                const [leader, base] = combo.split('/');
                baseCounts[base] = (baseCounts[base] || 0) + count;
            }

            const sortedBases = Object.entries(baseCounts).sort((a, b) => b[1] - a[1]);

            const labels = sortedBases.map(x => x[0]);
            const values = sortedBases.map(x => x[1]);

            // Colors based on Base Aspect
            const colors = labels.map(baseName => {
                const aspects = baseAspects[baseName];
                return aspects ? ASPECT_COLORS[aspects[0]] : '#a4b0be';
            });

            let aspectDistribution = {};

            for (const [comboName, count] of Object.entries(data.combinations)) {
                const [leader, base] = comboName.split('/');
                const aspects = getAspects(leader, base);

                for (const aspect of aspects) {
                    if (!aspectDistribution[aspect]) aspectDistribution[aspect] = 0;
                    aspectDistribution[aspect] += count;
                }
            }

            // Prepare Aspect Data (excluding Alignments and None)
            const aspectArray = Object.entries(aspectDistribution)
                .filter(([name]) => !alignments.includes(name) && name !== "None")
                .sort()
                .map(([name, count]) => ({ name, count }));

            const aspectLabels = aspectArray.map(a => a.name);
            const aspectValues = aspectArray.map(a => a.count);

            const aspectColors = aspectLabels.map(label => ASPECT_COLORS[label] || '#a4b0be');

            // Prepare Alignment Data
            const alignmentArray = Object.entries(aspectDistribution)
                .filter(([name]) => alignments.includes(name))
                .sort()
                .map(([name, count]) => ({ name, count }));

            const alignmentLabels = alignmentArray.map(a => a.name);
            const alignmentValues = alignmentArray.map(a => a.count);
            const alignmentColors = ['#ffffff', '#000000']; // White/Black for Heroism/Villainy


            const totalAspects = aspectValues.reduce((a, b) => a + b, 0);
            const totalAlignments = alignmentValues.reduce((a, b) => a + b, 0);

            baseChartInstance = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            data: values,
                            backgroundColor: colors,
                            borderColor: '#000000',
                            borderWidth: 1
                        },
                        {
                            data: aspectValues,
                            backgroundColor: aspectColors,
                            borderColor: '#000000',
                            borderWidth: 1,
                        },
                        {
                            data: alignmentValues,
                            backgroundColor: alignmentColors,
                            borderColor: '#000000',
                            borderWidth: 1,
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onHover: (event, elements, chart) => {
                        if (!pieChartInstance) return;

                        if (elements && elements.length) {
                            // Something is hovered in Base Chart
                            const index = elements[0].index;
                            const activeElements = [];

                            if (elements[0].datasetIndex === 0) {
                                const baseName = chart.data.labels[index];
                                // Find matching indices in Deck Pie Chart (dataset 0)
                                pieChartInstance.data.labels.forEach((label, i) => {
                                    const parts = label.split('/');
                                    // Check if label matches "Leader/Base" format and Base matches
                                    if (parts.length === 2 && parts[1].trim() === baseNames[baseName]) {
                                        activeElements.push({ datasetIndex: 0, index: i });
                                    }
                                });
                            } else if (elements[0].datasetIndex === 1) {
                                const aspectName = aspectLabels[index];

                                pieChartInstance.data.labels.forEach((label, i) => {
                                    const parts = label.split('/');
                                    // Check if label matches "Leader/Base" format and Aspect matches
                                    if (parts.length === 2) {
                                        const aspects = getAspectsByName(parts[0], parts[1]);
                                        if (aspects.has(aspectName)) {
                                            activeElements.push({ datasetIndex: 0, index: i });
                                        }
                                    }
                                });
                            } else if (elements[0].datasetIndex === 2) {
                                const alignmentName = alignmentLabels[index];

                                pieChartInstance.data.labels.forEach((label, i) => {
                                    const parts = label.split('/');
                                    // Check if label matches "Leader/Base" format and Aspect matches
                                    if (parts.length === 2) {
                                        const aspects = getAspectsByName(parts[0], parts[1]);
                                        if (aspects.has(alignmentName)) {
                                            activeElements.push({ datasetIndex: 0, index: i });
                                        }
                                    }
                                });
                            }


                            pieChartInstance.setActiveElements(activeElements);
                            pieChartInstance.update();
                        } else {
                            // Nothing hovered, clear highlight
                            pieChartInstance.setActiveElements([]);
                            pieChartInstance.update();
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: false,
                        },
                        tooltip: {
                            callbacks: {
                                title: function (context) {
                                    // Override title for inner rings to show the correct label
                                    if (context[0].datasetIndex === 1) { // Aspects
                                        return aspectLabels[context[0].dataIndex];
                                    }
                                    if (context[0].datasetIndex === 2) { // Alignment
                                        return alignmentLabels[context[0].dataIndex];
                                    }
                                    return baseNames[context[0].label];
                                },

                                label: function (context) {
                                    let label = baseNames[context.label] || '';
                                    let datasetTotal = data.totalGameCount; // Default to total games for Decks

                                    if (context.datasetIndex === 1) {
                                        label = aspectLabels[context.dataIndex];
                                        datasetTotal = totalAspects;
                                    } else if (context.datasetIndex === 2) {
                                        label = alignmentLabels[context.dataIndex];
                                        datasetTotal = totalAlignments;
                                    }

                                    const value = context.parsed || 0;
                                    const percentage = ((value / datasetTotal) * 100).toFixed(1);
                                    const formattedValue = currentDataSource === 'games' ? value.toLocaleString() : minutesToDays(value);
                                    return `${label}: ${percentage}% (${formattedValue})`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function showError(msg) {
            document.getElementById('content').innerHTML = `<div class="error">${msg}</div>`;
        }

        // Start
        init();

    </script>
</body>

</html>